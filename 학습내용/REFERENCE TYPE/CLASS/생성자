생성자정의                객체의 초기화 담당
종류                      생성자(){전역매개변수들의 초기값 지정을 위한내용},생성자(데이터타입){전역매개변수들의 초기값 지정을 위한 내용}
overloading              Class 이름(데이터 타입1){} Class 이름(데이터 타입2){} 다른 것들과 마찬가지로 데이터 타입 순서에 따라 구분한다.
생성자 tip                 오류를 막기 위해 this 사용
기본 생성자 정보 불러오기    this();








-----------------------------------------------------------------------------------------------------------------------------
생성자란?
class 명과 똑같은 이름을 가지는것 .
객체의 초기화를 담당한다.(변수의 초기값들을 미리 지정한다. )
리턴값은 없지만 void라는 키워드를 사용하지 않는다. 
void가 있으면 생성자가 아니라 일반 메소드가 되어버린다. 

---------------------------------------------------------------------------------------------------------------------------------
종류
매개 변수가 없는 생성자 
생성자(){전역매개변수들의 초기값 지정을 위한내용}
Marine() {// 매개변수가 없는 생성자 .
		hp = 200;
		x = 1;
		y = 2;
		공격력 = 8;
		공격속도 = 20;
		방어력 = 0;
		사거리 = 10;
		이동속도 = 12;

	}




매개 변수가 있는 생성자
생성자(데이터타입){전역매개변수들의 초기값 지정을 위한 내용}
Marine(int a) {
		hp = a;
		x = 1;
		y = 2;
		공격력 = 8;
		공격속도 = 20;
		방어력 = 0;
		사거리 = 10;
		이동속도 = 12;
		System.out.println("매개변수 있는 생성자");
	}
  
  객체 있는 class에 
  Marine Marine2 = new Marine(200); <-int a에 200값이 들어가고 hp=a;의 값이 변한다. 
  
  
 *생성자의 특징
  생성자가 따로 없다면 매개변수없는 생성자(기본생성자)가 1개 존재하는것으로 처리해준다(virtual machine이 판단한다.)
   기본 생성자는 멤버변수의 값을 기본 값으로 초기화 해준다. (0 or null)
-----------------------------------------------------------------------------------------------------------------------------
 생성자 overloading
 Class 이름(데이터 타입1){}
 Class 이름(데이터 타입2){} 다른 것들과 마찬가지로 데이터 타입 순서에 따라 구분한다. 
 --------------------------------------------------------------------------------------------------------------------------
 생성자 tip -this의 사용 
이름=이름;(x)
보통 변수에서 가장 가까운 변수를 찾는데  오른쪽에 오는 이름은 String 이름을 참고한다. 
하지만 왼쪽에 오는 이름은 전역변수를 참고 해야 하는데 특성상 가장 가까운 변수를 참고하기 때문에 String 이름을 참고해 오류가 난다.
그것을 막기위해 왼쪽에 this.이름이라고 표현을 해주어 전역변수를 참고한다는 것을 직접 가리켜 주어야 한다.
this는 자기자신을 가리키는 참조변수이다.
하지만 만약 혼동 되지 않는다면 ex)이름=이름1 생략한체 사용한다.
 ex)
 class 지정 class
 Human01(String 이름, int 나이, String 직업) {
		
		this.이름 = 이름;
	        this.나이 = 나이;
		this.직업 = 직업;
 }
 객체 있는 class
 Human01 h2 = new Human01("구마적", 25, "남", "000-0000-0000");
 
 -------------------------------------------------------------------------------------------------------------------------------
 생성자에서 입력정보 외에 정보를 기본값이 아닌 이전에 입력한 기본생성자 정보를 불러와 입력하는 방법?
 
 기본 생성자를 불러와서 호출하는 방법 즉  입력값을 제외한 나머지 값은 기본생성자를 불러와서 채워 넣는것. 나이=0 null같은게 안나오도록 
	this(); 이걸 넣으면 된다.
  
 ex)
 Human(String 이름, String 직업, String 성별) {
		this();             <-기본생성자를 불러오는 것이다. 
		
		this.이름 = 이름;

		this.성별 = 성별;

		this.직업 = 직업;
		

	}
  
  주의할점은 항상 위에 와야한다 . 아래에 두면 입력값을 덮어 씌우게 된다.
  
  
  기본 생성자 정보 뿐만 아니라 매개변수의 순서를 맞춰주면 다른 생성자의 정보도 기본값으로 불러올 수 있다.
 ex)
 Human(String 이름, int 나이, String 성별, String 전화번호, String 직업) {
		this(이름,직업,성별);                          <- 매개변수 순서를 맞춰서 다른 생성자 정보를 불러옴
		this.이름 = 이름;
		this.나이 = 나이;
		this.성별 = 성별;
		this.전화번호 = 전화번호;
		this.직업 = 직업;

	}
---------------------------------------------------------------------------------------------------------------------
다른 생성자에서 정보 불러올때 헷갈리는것
this(매개변수)
Human(String 이름a, int 나이a, String 성별a) {
this("이름a",20, "성별a","전화번호");
1.다른 생성자에서 정보를 받아오기 위해선 생성자 내에서 맨 위에 있어야 하고 this();(또는 this(매개변수)명령어가 겹치면 안된다.) 또한 받아오려는 생성자가 받고자하는 생성자보다 위에 있어야한다.
2.this(매개변수)에서 어떤 생성자를 가져올지는()안의 매개변수 type 순서에 따라서 판별해 확인후 해당 생성자의 정보를 가져온다.ex) this(string,int,string,string)인 생성자를 찾는다.
3.정보를 가져오고 나면  매칭을 하는데 this()의 ()안에 받는 생성자의 매개변수 이름이 있다면 그곳에 들어가게 된다. 없으면 ()안에 data type이 문자라면 ""표시를 없으면 그냥 수를 써주어야한다.

		
Human   iu2=new Human("IU",20,"여");
iu.상태보기(); 를 출력하게 되면  this(매개변수)의 매개변수에 적은 내용과는 상관없이(데이터타입은 상관있음) 다른 생성자의 정보를 불러와 적용한다.
        이름:IU
        직업:가수
        전화번호:010-0000-0000
        성별:여
        나이:26

*주의할점 
1.생성자의 접근지정자가 default면 다른 package에서 객체를 초기화 할때 오류가 나온다. 
 Marine m = new Marine();     <- Marine class package가 A에 있고 생성자가 default면 불가 
                              <- Marine class package가 A에 있고 생성자가 PUBLIC이면가능 


*임의로 초기화 하고 객체 만들기  
Class 객체이름 = null; 

*주의할점
자바 언어에서 가장 빈번히 보게 되는 에러이다. 참조값이 null이라 발생한다.
class이름 객체이름=null;
객체이름.method(); <-에러가 난다.
왜냐하면 객체의 주소를 보고 heap에 찾아가는것까지는 가능하나 null이 되면 heap에 찾아가도 뭘 실행해야 할지 모르게 되기 때문이다.


