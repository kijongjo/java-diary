상속이란 ? 
public class 자식class 이름 extends 부모class{}
부모가 가지고 있던 변수와 method를 자식이 그대로 물려받는 것을 말한다 .
둘의 연관성을 따져보아 자식class의 경우에는 기존에 부모 class가 가지고 있던 기능에서 
더 추가 하고 싶은 기능만 추가해주면 끝나기 때문에 효율적이다. 


*super();?
부모 자식간의 class 관계가 형성이 되면 자식 class의 객체를 생성하고나서 Member변수를 정의하지않고 
또 기본생성자를 통해 초기화를 하지 않아도 값이 나오는 것을 알 수가 있다. 


 ex)
SuperMan sm = new SuperMan();
System.out.println(sm.이름);     

결과값: 아이유 

이는 부모 class가 가지고 있던 생성자를 불러오는 코드가 자식 class에 있기 때문인데 그것이 super();이다 
super();는 부모 class의 정보를 불러오는 것을 말한다 .
(this(나를 가리킴),super(부모를 가리킴),this(); 나를 가리키는 생성자 , super();부모를 가리키는 생성자)


*헷갈리지 말아야 할점 
기본생성자(){ }를 쓰지 않아도 super();가 발동되는데 왜 그럴까? 
기본적으로 class에는 기본사항을 적는생성자(){}를 쓰지않아도 적어도 1개는 있다고 치기 때문이다.
즉 아무런 것도 적지않고 출력하면 0과NULL이 나오게 되는데 이게 기본생성자를 이루고 있다.


*매개변수를 가지는 생성자를 만들 경우
super(매개변수);를 통해 부모 class의 매개변수 있는 생성자를 가지고 온다. 여기에서 매개변수는 가지고 오고 싶은것에대해서
순서에 맞게 작성해 주어야 한다. 
또한 super에 없는 것을 추가하고싶은경우엔 this.을 통해 추가해 준다. 

ex)
SuperMan(String 이름, String 직업, int 나이, float 키, float 몸무게) {
		// 부모 생성자 중에 가져올 것에 대해서 매개변수를 적어주고 (순서에맞게) 그중 없는것을 따로 추가해준다. 부모(기본),자식(확장)
		super(이름, 직업, 몸무게, 키);
		this.나이 = 나이;

---------------------------------------------------------------------------------------------------------------------------------------
Overriding(재정의)
상속하여 받는 정보에 대해서 수정하는것
만약 바꾸려는 것이 method라면 부모 method와 똑같은 method 명을 입력한 후에 
내용을 변경한다. 주의할 점은 자식 method의 경우 부모 method보다 제한지정자가 더 허용적이어야만 한다. 
즉  (부모=public 자식 = default x   부모=defult 자식 =protected,public o)


*@Override
 compiler에게 상속받는게 맞는지 확인좀 해달라는 말이다. 없으면 에러가 발생한다.
 만약 override했는데 부모의 노래부르기 기능을 바꾸고싶은데 노래부르자로 실수로 바꾸게 되어 노래부르기를 호출해도 부모 기능이 호출되는
 불상사가 발생.
 그것을 막기위해 override 표시를하고 노래부르기 이름이 노래부르자로 바뀌게 되면 에러가 발생하도록 막는다.

ex)
@Override
public void 노래부르기() {              <-노래부르기를 노래부르자로 바꾸게 되면 에러가난다 부모 method이름이 노래부르기이기때문.
		System.out.println("나 좋은 꿈을 꿨어요~");
		
*overriding overloading 비교
method overriding                                              method overloading

재정의(상속)                                                           다중정의

방법 
method 명 동일                                                      method 명 동일 
매개변수 type,갯수,순서 동일하다                                매개변수 type,갯수,순서 다르다 
접근지정자는 부모보다 허용적이어야 한다.
(부모=public 자식 = default x
 부모=defult 자식 =protected,public o)

부모보다 볼수 있는 범위가 같거나 넓어야 한다. 
부모보다 더 보호되면 불가능 하다 .		
--------------------------------------------------------------------------------------------------------------------------------------
자식의 값을 부모에게 overriding 하기 
부모의 참조 변수에 자식의 참조 값을 대입하는 것이 가능하다. 
만약 부모의 method 기능중 노래부르기가 있고 자식에게도 노래부르기가 있는데 자식의 노래부르기 내용이 수정된 채로 
부모의 참조 변수에 대입이 되면 부모의 노래부르기를 출력했을 때 자식의 노래부르기 내용이 출력이 된다. 즉 부모의 노래부르기가 자식의 
노래부르기 내용으로 Overriding 된것이다.

*주의할 점
자식에게 method 기능으로 부모에게는 없는 method A가 있다고 치자. overriding된 부모도 method A를 출력 할 수 있을까?
불가능하다 부모는 자신이 가진 method에 한해 자식의 method에서 일치하는 것만 찾아 출력할 수 있다. 

 데이터 저장 및 불러오기 원리
 stack                     heap 
부모                      부모
주소:#100                #100 내용(1,2)


자식                       자식
주소:#200                #200 내용(1,2,3,4)


부모의 주소가 자식 주소로 덮어 씌워지게 되고 부모.1을 하게 되면 부모class에서 주소를 따라가(.) 자식의 정보에서 원하는 내용을 찾은 후
부모 자신이 가지고 있던 정보를 토대로 사용가능한지 아닌지 판단 후에 출력하게 된다.

부모=자식; (대입)
부모                      부모 
주소:#200              #100 내용(1,2)  <-사용 중지



자식                      자식
주소:#200              #200 내용(1(부모 출력가능),2(부모 출력가능),3(부모출력불가),4(부모 출력불가))         

*그렇다면 사용 중지된 #100의 내용은 어떻게 될까? 
#100에 대해 참조하는 존재가 하나도 없다면 garbage collector라는 기능이 #100을 삭제하게 된다.
삭제를 하게되면 다시 #100을 불러 올 수 없다.



*자식간의 대입은 가능하다.

---------------------------------------------------------------------------------------------------------------------------------
상속에서의 강제 형변환 
자식 class에 부모 class를 대입하는 것은 불가능 하다. 하지만 자식 class에게서 대입받은 부모 class는 다시 자식 class로 대입이 가능하다.
다만 아무런 조치 없이 자식=부모;를 하고자 하면 오류가 나게 된다. 
p1 <-부모 class 객체 c1 <-자식 class 객체 c2<-자식 class 객체
P1 = c1;
c2=P1; (오류) 
이유: 그것은 compiler가 주소를 보기전에 둘의 관계를 먼저보는데 c2가 자식인데 부모인 p1이 c2가 들어갈 수 있겠어?라고 생각하게 된다. \
그래서 가능은하지만 관계때문에 안되는 것이다 . 
이를 해결하기 위해 강제형변환을 해서 넣을 수가 있다. 

즉 class도 형변환이 가능하다 (=객체 형변환)
----------------------------------------------------------------------------------------------------------------------------------
부모 객체 선언과 동시에 자식 정보를 바로넣기
Parent 부모객체이름 = new Child();

 Parent p1; <-어차피 parent의 생성자 주소를 버릴 것이니 new를 안한다.
 child c1 = new child(); <-c1의 주소를 p1에 대입할 것이다. 그런데 대입하고나면 c1은 더이상 안쓸것이다.
 두줄의 코드를 한줄로 줄이고 공간 낭비를 막기위해 쓰는 소스코드가 존재한다(즉 만들어진 c1을 버리고 p1의 주소생성도 막는것)
Parent 부모객체이름 = new Child();
