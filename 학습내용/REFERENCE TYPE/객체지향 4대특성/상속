상속이란 ? 
public class 자식class 이름 extends 부모class{}
부모가 가지고 있던 변수와 method를 자식이 그대로 물려받는 것을 말한다 .
둘의 연관성을 따져보아 자식class의 경우에는 기존에 부모 class가 가지고 있던 기능에서 
더 추가 하고 싶은 기능만 추가해주면 끝나기 때문에 효율적이다. 


*super();?
부모 자식간의 class 관계가 형성이 되면 자식 class의 객체를 생성하고나서 Member변수를 정의하지않고 
또 기본생성자를 통해 초기화를 하지 않아도 값이 나오는 것을 알 수가 있다. 


 ex)
SuperMan sm = new SuperMan();
System.out.println(sm.이름);     

결과값: 아이유 

이는 부모 class가 가지고 있던 생성자를 불러오는 코드가 자식 class에 있기 때문인데 그것이 super();이다 
super();는 부모 class의 정보를 불러오는 것을 말한다 .
(this(나를 가리킴),super(부모를 가리킴),this(); 나를 가리키는 생성자 , super();부모를 가리키는 생성자)


*헷갈리지 말아야 할점 
기본생성자(){ }를 쓰지 않아도 super();가 발동되는데 왜 그럴까? 
기본적으로 class에는 기본사항을 적는생성자(){}를 쓰지않아도 적어도 1개는 있다고 치기 때문이다.
즉 아무런 것도 적지않고 출력하면 0과NULL이 나오게 되는데 이게 기본생성자를 이루고 있다.


*매개변수를 가지는 생성자를 만들 경우
super(매개변수);를 통해 부모 class의 매개변수 있는 생성자를 가지고 온다. 여기에서 매개변수는 가지고 오고 싶은것에대해서
순서에 맞게 작성해 주어야 한다. 
또한 super에 없는 것을 추가하고싶은경우엔 this.을 통해 추가해 준다. 

ex)
SuperMan(String 이름, String 직업, int 나이, float 키, float 몸무게) {
		// 부모 생성자 중에 가져올 것에 대해서 매개변수를 적어주고 (순서에맞게) 그중 없는것을 따로 추가해준다. 부모(기본),자식(확장)
		super(이름, 직업, 몸무게, 키);
		this.나이 = 나이;

---------------------------------------------------------------------------------------------------------------------------------------
Overriding(재정의)
상속하여 받는 정보에 대해서 수정하는것
만약 바꾸려는 것이 method라면 부모 method와 똑같은 method 명을 입력한 후에 
내용을 변경한다. 주의할 점은 자식 method의 경우 부모 method보다 제한지정자가 더 허용적이어야만 한다. 
즉  (부모=public 자식 = default x   부모=defult 자식 =protected,public o)


*@Override
 compiler에게 상속받는게 맞는지 확인좀 해달라는 말이다. 없으면 에러가 발생한다.
 만약 override했는데 부모의 노래부르기 기능을 바꾸고싶은데 노래부르자로 실수로 바꾸게 되어 노래부르기를 호출해도 부모 기능이 호출되는
 불상사가 발생.
 그것을 막기위해 override 표시를하고 노래부르기 이름이 노래부르자로 바뀌게 되면 에러가 발생하도록 막는다.

ex)
@Override
public void 노래부르기() {              <-노래부르기를 노래부르자로 바꾸게 되면 에러가난다 부모 method이름이 노래부르기이기때문.
		System.out.println("나 좋은 꿈을 꿨어요~");
		
*overriding overloading 비교
method overriding                                              method overloading

재정의(상속)                                                           다중정의

방법 
method 명 동일                                                      method 명 동일 
매개변수 type,갯수,순서 동일하다                                매개변수 type,갯수,순서 다르다 
접근지정자는 부모보다 허용적이어야 한다.
(부모=public 자식 = default x
 부모=defult 자식 =protected,public o)

부모보다 볼수 있는 범위가 같거나 넓어야 한다. 
부모보다 더 보호되면 불가능 하다 .		
--------------------------------------------------------------------------------------------------------------------------------------
자식의 값을 부모에게 overriding 하기 
부모의 참조 변수에 자식의 참조 값을 대입하는 것이 가능하다. 
만약 부모의 method 기능중 노래부르기가 있고 자식에게도 노래부르기가 있는데 자식의 노래부르기 내용이 수정된 채로 
부모의 참조 변수에 대입이 되면 부모의 노래부르기를 출력했을 때 자식의 노래부르기 내용이 출력이 된다. 즉 부모의 노래부르기가 자식의 
노래부르기 내용으로 Overriding 된것이다.

*주의할 점
자식에게 method 기능으로 부모에게는 없는 method A가 있다고 치자. overriding된 부모도 method A를 출력 할 수 있을까?
불가능하다 부모는 자신이 가진 method에 한해 자식의 method에서 일치하는 것만 찾아 출력할 수 있다. 

 데이터 저장 및 불러오기 원리
 stack                     heap 
부모                      부모
주소:#100                #100 내용(1,2)


자식                       자식
주소:#200                #200 내용(1,2,3,4)


부모의 주소가 자식 주소로 덮어 씌워지게 되고 부모.1을 하게 되면 부모class에서 주소를 따라가(.) 자식의 정보에서 원하는 내용을 찾은 후
부모 자신이 가지고 있던 정보를 토대로 사용가능한지 아닌지 판단 후에 출력하게 된다.

부모=자식; (대입)
부모                      부모 
주소:#200              #100 내용(1,2)  <-사용 중지



자식                      자식
주소:#200              #200 내용(1(부모 출력가능),2(부모 출력가능),3(부모출력불가),4(부모 출력불가))         

*그렇다면 사용 중지된 #100의 내용은 어떻게 될까? 
#100에 대해 참조하는 존재가 하나도 없다면 garbage collector라는 기능이 #100을 삭제하게 된다.
삭제를 하게되면 다시 #100을 불러 올 수 없다.



*자식간의 대입은 가능하다.

---------------------------------------------------------------------------------------------------------------------------------
상속에서의 강제 형변환 
자식 class에 부모 class를 대입하는 것은 불가능 하다. 하지만 자식 class에게서 대입받은 부모 class는 다시 자식 class로 대입이 가능하다.
다만 아무런 조치 없이 자식=부모;를 하고자 하면 오류가 나게 된다. 
p1 <-부모 class 객체 c1 <-자식 class 객체 c2<-자식 class 객체
P1 = c1;
c2=P1; (오류) 
이유: 그것은 compiler가 주소를 보기전에 둘의 관계를 먼저보는데 c2가 자식인데 부모인 p1이 c2가 들어갈 수 있겠어?라고 생각하게 된다. \
그래서 가능은하지만 관계때문에 안되는 것이다 . 
이를 해결하기 위해 강제형변환을 해서 넣을 수가 있다. 

즉 class도 형변환이 가능하다 (=객체 형변환)
----------------------------------------------------------------------------------------------------------------------------------
부모 객체 선언과 동시에 자식 정보를 바로넣기
Parent 부모객체이름 = new Child();

 Parent p1; <-어차피 parent의 생성자 주소를 버릴 것이니 new를 안한다.
 child c1 = new child(); <-c1의 주소를 p1에 대입할 것이다. 그런데 대입하고나면 c1은 더이상 안쓸것이다.
 두줄의 코드를 한줄로 줄이고 공간 낭비를 막기위해 쓰는 소스코드가 존재한다(즉 만들어진 c1을 버리고 p1의 주소생성도 막는것)
Parent 부모객체이름 = new Child();

-----------------------------------------------------------------------------------------------------------------------------------
*
부모 참조변수=자식 참조값;이 가능한 것을 이용해 코드를 효율적으로 줄이기 

부모 P > 자식 A,B,C,D이 있고 
부모 변수 x  자식 객체 a,b,c,d
어떤 CLASS E 에서 P의 자식들 A,B,C,D,에게 공통의 method로 일일이 관계를 만들어야 한다면 
method(a)
method(b)                           
                -----------------> method(P x) 로 줄일 수 있다.
method(c)                    즉 P a,P b,P c,P d가 가능하다.
method(d)

-----------------------------------------------------------------------------------------------------------------------------------
상속 사용의 신중함 필요성과 Class의 member 변수로써 사용하기
상속 is로 판단. 멤버변수 has로 판단
상속   : A IS a B(경찰이 총이다. X<-상속 쓰면 안됨.) (사람이 포유류다. O<-상속 써도 됨.)
멤버변수:A has a B(경찰은 총을 가지고 있다. O<-MEMBER변수로 가져도 됨.) (강아지는 포유류를 가지고 있다, X <-MEMBER변수로 넣으면 안됨.)


*Class를 member변수로써 사용하기
상위 class에서 
class를 다른 class의 member변수로 설정. setter(class 변수이름){this.class변수 변수이름 = 변수이름 }
                                       getter(){하위클래스 변수이름.기능();}
하위 class에서 
method(){};
출력 class에서
하위 클래스 객체 a 생성
상위 클래스 객체 b 생성
b.setter(하위클래스 객체 a);
b.getter();


예를 들어 경찰class와 총 class가 있다고  치자. 경찰과 총을 상속관계로 묶게 되면 경찰은 항상 총을 손에 들고 다니는 상황이 발생 된다. 
평상시에는 넣어 두었다가 필요할 때 꺼내 쓰도록 만드는게 필요하다 .
 순서:
 상위 class에서 
class를 다른 class의 member변수로 설정. setter(class 변수이름){this.class변수 변수이름 = 변수이름 }
                                       getter(){하위클래스 변수이름.기능();}
하위 class에서 
method(){};
출력 class에서
하위 클래스 객체 a 생성
상위 클래스 객체 b 생성
b.setter(하위클래스 객체 a);
b.getter();
 
ex)
상위 class
public class Police {
String name, age, 계급;
Gun g;

public void setgun(Gun g) {
		this.g = g;}
		
public void getuse() {                              
		g.fire();  	
		
-------------------------------------------------		
하위 class
public class Gun {
	int bullet;

	public Gun() {
		bullet = 6;

	}

	public void fire() {
		if (bullet > 0) {
			System.out.println("빵~~!");
			bullet--;
			System.out.println("남은 총알:"+bullet);
		} else

		{
			System.out.println("틱~");
		}
	}
-------------------------------------------------
호출 class
public class TestMain3 {
	public static void main(String[] args) {
		Gun g = new Gun();
		Police p1 = new Police();		
p1.setgun(g);
p1.getuse();


원리:
police class 안에

1.Gun class를 member 변수로 지정                                     <-논리:police has a Gun
Gun g; 

2.하지만 지금 상태에서 g는 null로 참조값을 가지지 않음.                 <-sysout(g) 오류 

3.g가 참조값을 통해 HEAP에 들어가서 무엇을 할 수있는지 알수 있도록 만들기 위해 
  set(Gun g){this.g=g;}     <- 참조값 부여됨 .  
  매개변수에 대입되는 값은 Gun class의 객체여야만 Police의 Gun g에 참조값을 부여할 수가 있다 . 


4.Police의 Member 변수인 Gun g에 참조값이 부여된다고 해서 p1.fire();를 쓸 수 있는 것은 아니고 
  멤버변수인 g에 참조값이 부여되었으니 참조값 주소를 따라 들어가서 method를 가지고와 실행할 수 있도록
  get method에 fire();기능을 넣어 출력해 간접적으로 p1.fire();이 되도록 할 수 있다.
  get(){g.fire();}
