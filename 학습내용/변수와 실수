요약

변수의 정의         자료처리를 위한 이름이 부여된 메모리 영역
변수 종류           정수형 변수, 실수형 변수
정수형 변수의 종류   byte short int long
변수선언            자료형 변수명
상수                ; , = 
실수형 종류         Float 타입, double 
형변환             맥주잔에 소주잔 용량을 담을 수는 있지만 소주잔엔 맥주잔 용량을 담지 못하고 버리게된다.
문자형              char String
자료형 연산의 특징  int이하의 자료형끼리 연산하면 결과는 int형이 된다. 
*출력시 중요 약속   숫자+숫자 ==>숫자 , 문자+숫자==>문자





변수란?
자료처리를 위한 이름이 부여된 메모리 영역을 일컫는다.
--------------------------------------------------------------------------------------------------------------------------------
변수의 종류?
Primitive type => 대표적인 예로 정수형 변수가 있다.
Reference type




정수형 변수의 가장 작은 크기는 1byte
1byte는 8bit의 모임이다.
--------------------------------------------------------------------------------------------------------------------------------
정수형 변수의 자료크기의 종류?

byte short  int  long
8bit 16bit 32bit 64bit


*eclipse의 경우 tip

의미 있는 키워드는 색깔이 나타난다. 
즉 색깔이 있어야 하는 곳에 없으면 오타. 그리고 틀리면 밑줄을 쳐준다.
또한 양쪽 사이드라인에 틀렸다고 표시가 난다.

*자동 문장 완성 기능 

main 치고 ctrl+스페이스 치면 알아서 public static void main~ 이 자동으로 만들어진다.

sysout도 치면 자동완성

------------------------------------------------------------------------------------------------------------------

자료형 변수명; 형식으로 기입한다.

public class VarEx1 {
	public static void main(String[] args) {
		
          byte b1;                <-   변수를 선언한다.
	b1=10;                         b1에 10을 넣자. 
           }                           메모리 안에 b1이라는 공간이 생기는데 
                                       이건 8bit의 공간을 확보해달라는 말이다.

	 }

 * =는 대입 연산자 할당 연산자라고 한다. 
         즉 b1은 10이 아니라 b1에 10을 넣어라 라는 말이다. 컴퓨터 언어는 그렇게 해석하게된다.
ex)b1 =b1+1; 이 컴퓨터 언어를 이해하지 못했다면 
 전혀 성립하지 않지만 컴퓨터 언어측면에선 
 b1= b1+1을 넣어라 라는 말이 된다. 


*변수 출력하기 

System.out.println(b1);             <- 변수를 넣엇으면 출력해야 넣엇을 지 알수 있다.

최종
package basic;
public class VarEx1 {
	public static void main(String[] args) {
                                                byte b1;
                                                b1 =10 ;
                                                System.out.println(b1);
	}
	 }






****
그런데 
package basic;
public class VarEx1 {
	public static void main(String[] args) {
                                                byte b1;
                                                b1 =10 ;
                                                System.out.println(b1);
	}
	 }
에서 b1에 128을 넣으면 에러가 나온다. 
이유:
b1에 주어진 공간 때문이다.
1byte 
8자리가 주어진다
0000 0000
^
맨 앞자리는 부호를 나타낸다 0은 양수 1은 음수

 ^ 
 2^6
  ^
  2^5
   ^
   2^4
    '
    '
    ' 
             전부 더하면 127이 한계이다.



-128부터 +127까지가 표현할수 있는 최대이다. in 1byte

-----------------------------------------------------------------------------------------------------------------
short 크기의 변수 k를 선언

k변수에 5000값을 대입
k변수의 값을 화면에 출력하고자 한다.





package basic;
public class VarEx1 {
	public static void main(String[] args) {
                                                short k;
                                                k =5000 ;
                                                System.out.println(k);
	}
	 }



매 라인마다 ;넣어서 라인의 명령이 끝이다라는것을 선언.

short는 
16bit라서 
16개의 칸 

앞의 부호 자리를 빼고

-2^15~2^15-1 -> -32768~32767까지 표현한다.

*선언과 대입을 한번에 하는 것을 변수를 초기화 한다고 한다.
package basic;
public class VarEx1 {
 public static void main(String[] args) {
int i = 100000; // 초기화
	 
			 System.out.println(i);
	     }
	 }

---------------------------------------------------------------------------------------------------------------------
상수란?
항상 같은 값을 가지는 수. 



***
                          //자료형 변수명 = 상수;
			 //상수는 항상 동일한 값을 갖는 수 
			 //상수형은 변수 형과 동일
			 //int 이하의 자료의 경우엔 int 타입을 쓴다
  long type의 경우엔?  
    long t = 300L;        <- long형 상수의 경우엔 상수에 L를 붙여준다.
    System.out.println(t);

-------------------------------------------------------------------------------------------------------------------------

실수형 타입의 자료? 
소수점 자리나 아주 큰수를 표현하기 위해서 .을 이용해 표현 하는데 지수부와 가수부를 변화시켜 
원하는 수를 표현하는것도 포함한다 .

종류?
Float타입과 Double타입이 있다.


Float 타입의 경우 
소수점의 위치를 바꾸어서 엄청나게 큰수와 작은 수를 표현할 수 있다.
소수 점은 Floating point라고 한다.
(부동 소수점.)

Double 타입의 경우 
Float 타입보다 훨씬 더 큰 지수부와 가수부를 저장할 수 있다. 

*실수형의 기본은 double이다 .

*자바는 자료형을 아주 민감하게 취급하는 언어이다.


+의 쓰임과 문자열
ex)

// 실수형 변수 선언 
    //FLOATA 타입의 경우 상수 끝에 F를 붙인다.
    float f1 =3.14F;
    System.out.println(f1);
    
    double d1=3.25D;
    //실수형의 기본은 double이다.
    double d2=3.25;
    // +:문자열과 문자열을 연결하는 연결 연산자 oracle의 ||과 같다.
    System.out.println("f1"+f1);

EX)
package basic;
//홍길동은 20살이며 키가 182.3 입니다.
//20 정수형 변수 i에 대입
//182.3은 실수형 변수 h에 대입
//화면 출력
public class VarEx2 { public static void main(String[] args) {
	//정수형 변수 i=20
	byte i = 20;
	//실수형 변수 h=182.3이고 실수형 변수에 의해 D를 표시
	double h=182.3D;
	//출력                     ""문자열 넣기 +는 이어서 쓰기 위함.
 System.out.println("나이"+":"+i+"살");
 System.out.println("키"+":"+h);
	    //}를 위치 표시하는걸 연습하기 , 회사마다 괄호에 대한 규칙 존재
         }

}



*}위치 두는 것을 연습하자. 코드가 길어지면 헷갈리기 시작한다.

---------------------------------------------------------------------------------------------------------------
형변환?
byte b1 =10
short sh1 =30; 이다.


sh1= b1은 되는데 b1=sh1은 안된다? 왜그럴까?

complier는 자료안에 들어있는 수를보고 판단하지 않는다. 비록 b1이 sh1의 10을 담을수 있을만한 공간을
가진 자료타입이라도  complier는 단순히 자료형 타입만 보고 b1이 sh1보다 더 큰 타입인지 따져보고 판단해
안된다고 오류가 뜨는 것이다.  -overflow-

그래도 강제적으로 담는 방법?

short sh1을 강제적으로 작은사이즈로 변환시켜 담을 수 있는데 그것을 '형변환'이라 한다.

하지만 강제로 하게되면 담겨진 데이터의 일부가 손상될 수 있다. 

b1 =(byte)sh1;  <- sh1을 byte로 강제적으로 형변환 하라는 말이다.


 
	     short sh1 = 30;
	           // b1 변수 안에 들어 있는 값을 sh1라는 변수에 대입하라 
	           //sh1 = b1;
	           b1=(byte)sh1;
	           System.out.println("b1:"+b1);


만약 byte가 담을 수없는 수인 128을 넣게 되면 어떻게 될까?
--------------------------------------------------------------------------------------------------------------------
문자형 

char          String                                              <- char는 문자 하나를 저장, String은 문자 여러개를 저장
캐릭터 타입                                                            String은 앞에 대문자를 써야한다.

크기는 16bit 

us7 ascii <- 미국애들은 7bit면 문자 하나 저장 가능 . 한글은 못 담는다. 



한글의 경우 ko16ksc5601   하지만 특수한 모양의 한글은 깨졋음 
              16bit  



좀더 확장된 것들 ko16mswin949 한국 16비트 마이크로소프트 윈도우949


외국어 아랍어,러시아어등등 전부 표현할 수 있도록 만든것 
unicode

                                  

  //2byte 크기
	           char c1 ='a';
	           // ascii 코드 값으로도 저장가능하다 A:65 a: 97 0:48
	           char c2 = 97;
	           char c3='\u0061';
	           System.out.println("c1:"+c1);
                    //unicode로도 표현가능하다.
	           char c3='\u0061';
	           System.out.println("c1:"+c1);
	           System.out.println("c2:"+c2);
	           System.out.println("c3:"+c3);
	  c1:a
c2:a
c3:a


 //여러 글자를 쓰고 싶을 경우 str 즉 스트링을 쓴다. 그리고 여러글자는 ""를 써야한다.
	           string str="java";
	           System.out.println(str);





	     short sh1 = 128;
	           // b1 변수 안에 들어 있는 값을 sh1라는 변수에 대입하라 
	           //sh1 = b1;
	           b1=(byte)sh1;
	           System.out.println("b1:"+b1);
	  

b1:10
b2:50
b1:-128   <- -128이 된다.  

 왜냐하면 8byte를 넘는 것은 이진법에서 잘라버리기 때문이다 

만약 정상적으로 표현한 값이 
  11 1110 0000 가 128이라면 1byte 안에 넣으려면 8칸이기 때문에 overflow가 발생해 도중에 앞에서 짤리기 때문에
1110 0000 이되는데 맨앞의 수는 부호를 나타내는 것이라 1 -> - 부호로 표시가 되어 -128이 되는것이다 .

  만약 1280을 넣어도

정상적인 값 1110 1110 1110 0001 0000 이라면 8칸 짤리니
                         0001 0000이 되어 +값이 될 수도있다. 그건 아무도 모른다 .
-------------------------------------------------------------------------------------------------
자료형 연산의 특징
int 이하의 자료형끼리 연산하면 결과는 int가 된다.
short+int = int, byte+ int=int

ex)
                byte b1 = 100;                            <-byte 끼리의 합 =int자료형
		byte b2 = 20;                               때문에 
		int c = b1 + b2; // byte c = b1+b2;       <-byte에 담을 수 있는 수여도 int로 정의해 담아야한다.
		System.out.println(c);

*정수형끼리 계산하면 정수형의 형태로 보여져야한다.
ex)
int a=10
int b=20;
System.out.println("a+b" + (a / b));결과는 0이다 
원래는 소수인 0.5가 정확하지만 정수형끼리 계산하면 정수형의 형태로 보여져야한다.

*float과 int가 만나면 같으 byte 크기이지만 float으로 변환이 일어난다.

ex)
int total = kor + eng + mat;
		// 출력 총점 문자와 총합
		System.out.println("총점:" + total);
		// 실수형 타입의 변수 정의
		float avg = total / 3.0f; // <-3.0f을 하면(folat정의하기) float 타입이 되고 값도 float이 나온다.
		// 출력 평균 문자와 평균
		System.out.println("평균:" + avg);// int 나누기 float 하면 float이 더 커서 float형이 된다.
----------------------------------------------------------------------------------------------------
*출력시 중요 약속
   숫자+숫자 ==>숫자
   문자+숫자==>문자
   
   "일"+1+1 -> 일11로 출력이 된다. 왜냐하면 문자 옆에 붙은 1이 문자로 인식되고 또 옆에 있는 숫자도 같이 
   문자로 인식되기 때문이다.












