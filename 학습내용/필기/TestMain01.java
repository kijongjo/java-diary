package day10;

import day09.Marine;

public class TestMain01 {
	public static void main(String[] args) {
		Parent P1 = new Parent();
		P1.잔소리하기();
		System.out.println("-----------------------------------------------");
		System.out.println("자식생성자");
		Child c1 = new Child();
		// 자식 생성자는 암시적으로 부모 생성자를 호출한다.

		c1.잔소리하기();
		c1.노래부르기();
		c1.클럽가기();

//내가 하기 싫은것까지 물려받을 수 있다......
//상속 받은 method가 마음에 들지 않는다면 ? 
//싫은 메소드와 동일한 메소드를 다시 작성한다.  <-이걸 method overriding이라고 한다. 
// 재정의라고 할 수 있다. 	

		Marine m;
		// 주소값을 주는게 안된다. 모든 CLASS CLASS가 다 각기 다른 자료형이라고 생각하면 된다. 그래서 서로 다른 CLASS에 참조값을
		// 줄수가 없다. m=P1;불가.
		Parent P2;
		P2 = P1;
		// p2 = p1; p1의 주소값을 p2에 담는다 .즉 같은 class는 서로 주소값을 줄 수가 있다.
		// 아닌 경우

		System.out
				.println("-------------------------------------------------------------------------------------------");

		P2.노래부르기();
		// 부모 참조 변수 = 자식의 참조값; 대입하는 것은 가능하다
		P2 = c1;
		P2.노래부르기();
		// 노래부르기가 c1의 노래부르기로 나오게 된다. 자식으로 OVERRIDE된 것으로 나온다. 하지만 P1이 아는것만 사용한다.
		// 이렇게 되면 기존의 HEAP에 저장된 P1의 내용이 잇을 텐데 만약 아무도 이것을 참조하지 않는다면 garbage collector가
		// 삭제한다. (용량 폭발을 줄임)
		// 한번 잃어버린 참조값은 다시 찾을 수 없다. 즉 p1 참조값 #200 > #100으로 변경 이후로 #200을 다시 찾아가서 활용하기 불가능

		// 안되는것
		// P2.클럽가기();
		// 그런데 덮어 썻는데도 자식의 기능인 P2의 클럽가기는 없다. p2는 자신이 가진 기능. 즉 아는 것만 쓴다.
		// c1=P1;은 불가능하다 .
		// 왜냐하면 c1에 노래하기 기능은 p1에도 있지만 클럽가기 기능은 c1에는 있었지만 p1에는 없기 때문이다.
	
		System.out.println("-------------------------------------------------------------------------------------------");
		P1 = c1;
		P1.노래부르기();
		P1.잔소리하기();
        
		Child c2 ; //<-객체를 만들어준게 아니다 . 이름만 만들어 준것이다. 
		
		c2 = c1;
		c2.클럽가기();
		
        // c2=p1;은 안된다 p1은 c1에게 주소를 받아와서 얘도 #100인데 왜 안될까?
		//그것은 compiler가 주소를 보기전에 둘의 관계를 먼저보는데 c2가 자식인데 부모인 p1이 c2가 들어갈 수 있겠어?라고 생각하게 된다. 
		//그래서 가능은하지만 관계때문에 안되는 것이다 . 이를 해결하기 위해 강제형변환을 해서 넣을 수가 있다. 즉 class도 형변환이 가능하다 (=객체 형변환)
		//c2=(child)P1;
		
	}

}
